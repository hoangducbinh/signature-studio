<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Signature Studio — Tách nền & chỉnh màu nét ký (Supersampled AA)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .checker {
      background-image: linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                        linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                        linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
    input[type="range"] { accent-color: #111827; }
    .btn { @apply px-3 py-2 rounded-2xl shadow-sm border text-sm font-medium; }
    .btn-primary { @apply bg-black text-white hover:bg-gray-800; }
    .btn-ghost { @apply hover:bg-gray-100; }
    .label { @apply text-xs uppercase tracking-wider text-gray-500; }
  </style>
</head>
<body class="bg-white text-gray-900">
  <header class="max-w-6xl mx-auto px-4 py-6">
    <h1 class="text-2xl md:text-3xl font-bold">✍️ Signature Studio</h1>
    <p class="text-gray-600 mt-1">Tách nền chữ ký từ ảnh chụp, chỉnh nét (anti‑alias + supersample), đổi màu, scale và xuất PNG nền trong — chạy 100% trên trình duyệt.</p>
  </header>

  <main class="max-w-6xl mx-auto px-4 pb-24">
    <section class="grid lg:grid-cols-3 gap-6 items-start">
      <div class="lg:col-span-1 space-y-4">
        <div class="p-4 border rounded-2xl">
          <label class="label">1) Tải ảnh chữ ký</label>
          <input id="fileInput" type="file" accept="image/*" class="mt-2 w-full" />
          <p class="text-xs text-gray-500 mt-2">Tip: Chụp trên giấy trắng, ánh sáng đều, nét ký đậm.</p>
        </div>

        <div class="p-4 border rounded-2xl space-y-4">
          <div>
            <div class="flex items-center justify-between">
              <label class="label">Ngưỡng tách nền (Threshold)</label>
              <label class="inline-flex items-center gap-2 text-xs">
                <input id="autoOtsu" type="checkbox" class="mr-1" checked /> Auto (Otsu)
              </label>
            </div>
            <input id="thresh" type="range" min="0" max="255" value="128" class="w-full" />
            <div class="text-xs text-gray-500">Giá trị: <span id="threshVal">128</span></div>
          </div>

          <div>
            <label class="label">Độ dày nét</label>
            <input id="stroke" type="range" min="-5" max="5" value="0" class="w-full" />
            <div class="text-xs text-gray-500">Mỏng ⟵ <span id="strokeVal">0</span> ⟶ Đậm</div>
          </div>

          <div>
            <div class="flex items-center justify-between">
              <label class="label">Màu chữ ký</label>
              <input id="color" type="color" value="#111111" class="w-10 h-8 border rounded-md p-0" />
            </div>
          </div>

          <div>
            <label class="label">Scale (kích thước xuất)</label>
            <input id="scale" type="range" min="0.25" max="3" step="0.05" value="1" class="w-full" />
            <div class="text-xs text-gray-500"><span id="scaleVal">1.00×</span></div>
          </div>

          <div class="flex gap-2 pt-2">
            <button id="processBtn" class="btn btn-primary">Tách nền</button>
            <button id="resetBtn" class="btn btn-ghost">Reset</button>
          </div>
        </div>

        <div class="p-4 border rounded-2xl space-y-2">
          <button id="exportBtn" class="btn btn-primary w-full">⬇️ Xuất PNG nền trong</button>
          <p class="text-xs text-gray-500">PNG sẽ được crop sát nét ký, nền trong suốt, màu theo chọn.</p>
        </div>
      </div>

      <div class="lg:col-span-2 grid md:grid-cols-2 gap-6">
        <div class="border rounded-2xl overflow-hidden">
          <div class="p-3 border-b text-sm font-medium">Ảnh gốc</div>
          <div class="checker flex items-center justify-center min-h-[300px]">
            <canvas id="origCanvas" class="max-w-full"></canvas>
          </div>
        </div>
        <div class="border rounded-2xl overflow-hidden">
          <div class="p-3 border-b text-sm font-medium">Kết quả (preview)</div>
          <div class="checker flex items-center justify-center min-h-[300px]">
            <canvas id="outCanvas" class="max-w-full"></canvas>
          </div>
        </div>
      </div>
    </section>

    <section class="mt-8 text-xs text-gray-500 leading-relaxed">
      <details>
        <summary class="cursor-pointer select-none font-medium text-gray-700">Cách hoạt động (kỹ thuật)</summary>
        <div class="mt-2 space-y-2">
          <p>Pipeline: supersample ×3 ở hậu trường → soft‑mask (alpha) thay vì nhị phân → co/giãn bằng nhân đĩa → blur nhẹ → downsample khi preview/xuất để triệt răng cưa.</p>
        </div>
      </details>
    </section>
  </main>

  <footer class="max-w-6xl mx-auto px-4 pb-8 text-xs text-gray-400">
    <p>© 2025 Signature Studio. Made for GitHub Pages.</p>
  </footer>

  <script>
    const fileInput = document.getElementById('fileInput');
    const origCanvas = document.getElementById('origCanvas');
    const outCanvas = document.getElementById('outCanvas');
    const processBtn = document.getElementById('processBtn');
    const exportBtn = document.getElementById('exportBtn');
    const resetBtn  = document.getElementById('resetBtn');

    const thresh = document.getElementById('thresh');
    const threshVal = document.getElementById('threshVal');
    const autoOtsu = document.getElementById('autoOtsu');
    const stroke = document.getElementById('stroke');
    const strokeVal = document.getElementById('strokeVal');
    const color = document.getElementById('color');
    const scale = document.getElementById('scale');
    const scaleVal = document.getElementById('scaleVal');

    const INTERNAL_SCALE = 3; // xử lý hi‑res để mượt mép

    let origImg = null;
    let mask = null; // Uint8ClampedArray alpha 0..255 ở work space
    let workW = 0, workH = 0;
    const workCanvas = document.createElement('canvas');

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function drawImageToCanvas(img, canvas, maxDim=2800){
      const ratio = Math.min(maxDim / img.width, maxDim / img.height, 1);
      const w = Math.round(img.width * ratio);
      const h = Math.round(img.height * ratio);
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,w,h);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, w, h);
      return {w, h};
    }

    function prepareWorkCanvas(displayW, displayH){
      workW = displayW * INTERNAL_SCALE;
      workH = displayH * INTERNAL_SCALE;
      workCanvas.width = workW;
      workCanvas.height = workH;
      const wctx = workCanvas.getContext('2d');
      wctx.imageSmoothingEnabled = true;
      wctx.imageSmoothingQuality = 'high';
      wctx.drawImage(origCanvas, 0, 0, workW, workH);
    }

    function toGray(data){
      const len = data.length/4;
      const gray = new Uint8ClampedArray(len);
      for(let i=0, j=0; i<data.length; i+=4, j++){
        const r=data[i], g=data[i+1], b=data[i+2];
        gray[j] = (0.2126*r + 0.7152*g + 0.0722*b) | 0;
      }
      return gray;
    }

    function otsuThreshold(gray){
      const hist = new Uint32Array(256);
      for(let i=0;i<gray.length;i++) hist[gray[i]]++;
      const total = gray.length;
      let sum = 0; for(let t=0;t<256;t++) sum += t * hist[t];
      let sumB=0, wB=0, wF=0, varMax=0, threshold=127;
      for(let t=0;t<256;t++){
        wB += hist[t]; if(wB===0) continue;
        wF = total - wB; if(wF===0) break;
        sumB += t * hist[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const varBetween = wB*wF*(mB - mF)*(mB - mF);
        if(varBetween > varMax){ varMax = varBetween; threshold = t; }
      }
      return threshold;
    }

    function makeSoftMask(gray, threshold, feather = 16) {
      const len = gray.length;
      const alpha = new Uint8ClampedArray(len);
      const tLo = threshold - feather;
      const tHi = threshold + feather;
      for (let i = 0; i < len; i++) {
        const g = gray[i];
        let a = 0;
        if (g <= tLo) a = 255;
        else if (g >= tHi) a = 0;
        else a = Math.round(255 * (1 - (g - tLo) / (tHi - tLo)));
        alpha[i] = a;
      }
      return alpha;
    }

    function boxBlurAlpha(alpha, w, h, r = 1) {
      if (r <= 0) return alpha;
      const out = new Uint8ClampedArray(alpha.length);
      const tmp = new Uint8ClampedArray(alpha.length);
      for (let y = 0; y < h; y++) {
        let acc = 0, count = 0;
        const row = y * w;
        for (let x = 0; x < w; x++) {
          const x0 = Math.max(0, x - r);
          const x1 = Math.min(w - 1, x + r);
          if (x === 0) {
            acc = 0; count = 0;
            for (let k = x0; k <= x1; k++) { acc += alpha[row + k]; count++; }
          } else {
            const prevOut = x - r - 1;
            const nextIn  = x + r;
            if (prevOut >= 0) { acc -= alpha[row + prevOut]; count--; }
            if (nextIn < w)  { acc += alpha[row + nextIn];  count++; }
          }
          tmp[row + x] = Math.round(acc / count);
        }
      }
      for (let x = 0; x < w; x++) {
        let acc = 0, count = 0;
        for (let y = 0; y < h; y++) {
          const y0 = Math.max(0, y - r);
          const y1 = Math.min(h - 1, y + r);
          if (y === 0) {
            acc = 0; count = 0;
            for (let k = y0; k <= y1; k++) { acc += tmp[k * w + x]; count++; }
          } else {
            const prevOut = y - r - 1;
            const nextIn  = y + r;
            if (prevOut >= 0) { acc -= tmp[prevOut * w + x]; count--; }
            if (nextIn < h)  { acc += tmp[nextIn * w + x];  count++; }
          }
          out[y * w + x] = Math.round(acc / count);
        }
      }
      return out;
    }

    function dilateDisk(bin, w, h, r){
      if(r<=0) return bin;
      const out = new Uint8Array(bin.length);
      const r2 = r*r;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          let val = 0;
          for(let dy=-r; dy<=r && !val; dy++){
            const yy = y+dy; if(yy<0||yy>=h) continue;
            const dy2 = dy*dy;
            for(let dx=-r; dx<=r; dx++){
              const xx = x+dx; if(xx<0||xx>=w) continue;
              if(dy2 + dx*dx > r2) continue;
              const idx = yy*w+xx;
              if(bin[idx]){ val=1; break; }
            }
          }
          out[y*w+x] = val;
        }
      }
      return out;
    }

    function erodeDisk(bin, w, h, r){
      if(r<=0) return bin;
      const out = new Uint8Array(bin.length);
      const r2 = r*r;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          let val = 1;
          for(let dy=-r; dy<=r && val; dy++){
            const yy = y+dy; if(yy<0||yy>=h) { val=0; break; }
            const dy2 = dy*dy;
            for(let dx=-r; dx<=r; dx++){
              const xx = x+dx; if(xx<0||xx>=w){ val=0; break; }
              if(dy2 + dx*dx > r2) continue;
              const idx = yy*w+xx;
              if(!bin[idx]){ val=0; break; }
            }
          }
          out[y*w+x] = val;
        }
      }
      return out;
    }

    function alphaDilateErode(alpha, w, h, s) {
      if (s === 0) return alpha;
      const bin = new Uint8Array(alpha.length);
      for (let i = 0; i < alpha.length; i++) bin[i] = alpha[i] > 0 ? 1 : 0;
      const r = Math.abs(s);
      const morphed = s > 0 ? dilateDisk(bin, w, h, r) : erodeDisk(bin, w, h, r);
      const out = new Uint8ClampedArray(alpha.length);
      for (let i = 0; i < morphed.length; i++) out[i] = morphed[i] ? 255 : 0;
      return boxBlurAlpha(out, w, h, Math.max(1, Math.round(r * 1.2)));
    }

    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : {r:17,g:17,b:17};
    }

    function findBoundingBox(m, w, h){
      let minX=w, minY=h, maxX=-1, maxY=-1;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          if(m[y*w+x] > 0){
            if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y;
          }
        }
      }
      if(maxX<minX || maxY<minY) return {x:0,y:0,w:0,h:0};
      return {x:minX, y:minY, w:maxX-minX+1, h:maxY-minY+1};
    }

    function renderPreview(){
      if(!origImg || !mask) return;
      const {r,g,b} = hexToRgb(color.value);

      const img = new ImageData(workW, workH);
      for(let i=0, j=0; i<img.data.length; i+=4, j++){
        const a = mask[j];
        img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=a;
      }

      const stage = document.createElement('canvas');
      stage.width = workW; stage.height = workH;
      stage.getContext('2d').putImageData(img, 0, 0);

      const octx = outCanvas.getContext('2d');
      outCanvas.width = Math.round(workW / INTERNAL_SCALE);
      outCanvas.height = Math.round(workH / INTERNAL_SCALE);
      octx.imageSmoothingEnabled = true;
      octx.imageSmoothingQuality = 'high';
      octx.clearRect(0,0,outCanvas.width,outCanvas.height);
      octx.drawImage(stage, 0, 0, outCanvas.width, outCanvas.height);
    }

    function process(){
      if(!origImg){ alert('Hãy tải ảnh chữ ký trước đã nhé!'); return; }
      const wctx = workCanvas.getContext('2d');
      const imgData = wctx.getImageData(0,0,workW, workH);
      const gray = toGray(imgData.data);

      let t = autoOtsu.checked ? otsuThreshold(gray) : parseInt(thresh.value);
      if(!autoOtsu.checked) t = clamp(parseInt(thresh.value), 0, 255);
      thresh.value = t; threshVal.textContent = String(t);

      let alpha = makeSoftMask(gray, t, 16);
      alpha = boxBlurAlpha(alpha, workW, workH, 1);
      const s = parseInt(stroke.value) * INTERNAL_SCALE;
      alpha = alphaDilateErode(alpha, workW, workH, s);

      mask = alpha;
      renderPreview();
    }

    function exportPng(){
      if(!mask){ alert('Chưa có kết quả để xuất. Nhấn "Tách nền" trước nhé!'); return; }
      const bbox = findBoundingBox(mask, workW, workH);
      if(bbox.w===0 || bbox.h===0){ alert('Không phát hiện được nét ký. Hãy giảm threshold hoặc tăng độ dày nét.'); return; }

      const scaleFactor = parseFloat(scale.value);

      const cropped = new ImageData(bbox.w, bbox.h);
      const {r,g,b} = hexToRgb(color.value);
      for(let y=0; y<bbox.h; y++){
        for(let x=0; x<bbox.w; x++){
          const srcIdx = (bbox.y + y) * workW + (bbox.x + x);
          const dstIdx = (y * bbox.w + x) * 4;
          const a = mask[srcIdx];
          cropped.data[dstIdx] = r;
          cropped.data[dstIdx+1] = g;
          cropped.data[dstIdx+2] = b;
          cropped.data[dstIdx+3] = a;
        }
      }

      const stage = document.createElement('canvas');
      stage.width = bbox.w; stage.height = bbox.h;
      stage.getContext('2d').putImageData(cropped, 0, 0);

      const outW = Math.max(1, Math.round((bbox.w / INTERNAL_SCALE) * scaleFactor));
      const outH = Math.max(1, Math.round((bbox.h / INTERNAL_SCALE) * scaleFactor));

      const tmp = document.createElement('canvas');
      tmp.width = outW; tmp.height = outH;
      const tctx = tmp.getContext('2d');
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = 'high';
      tctx.drawImage(stage, 0, 0, outW, outH);

      const url = tmp.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'signature.png';
      a.click();
    }

    function resetUI(){
      thresh.value = 128; threshVal.textContent = '128'; autoOtsu.checked = true;
      stroke.value = 0; strokeVal.textContent = '0';
      color.value = '#111111';
      scale.value = 1; scaleVal.textContent = '1.00×';
      const ctxO = origCanvas.getContext('2d');
      ctxO.clearRect(0,0,origCanvas.width, origCanvas.height);
      const ctxOut = outCanvas.getContext('2d');
      ctxOut.clearRect(0,0,outCanvas.width, outCanvas.height);
      origImg = null; mask = null; workW = 0; workH = 0;
    }

    fileInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      const img = new Image();
      img.onload = ()=>{
        const {w, h} = drawImageToCanvas(img, origCanvas);
        origImg = img;
        prepareWorkCanvas(w, h);
        mask = null;
        process();
      };
      img.onerror = ()=> alert('Không mở được ảnh. Hãy thử lại với file .jpg/.png/.webp');
      const reader = new FileReader();
      reader.onload = (ev)=>{ img.src = ev.target.result; };
      reader.readAsDataURL(file);
    });

    processBtn.addEventListener('click', ()=>{ if(origImg){ prepareWorkCanvas(origCanvas.width, origCanvas.height); process(); } });
    exportBtn.addEventListener('click', exportPng);
    resetBtn.addEventListener('click', resetUI);

    autoOtsu.addEventListener('change', ()=>{ thresh.disabled = autoOtsu.checked; if(origImg){ prepareWorkCanvas(origCanvas.width, origCanvas.height); process(); } });
    thresh.addEventListener('input', ()=>{ threshVal.textContent = thresh.value; });
    thresh.addEventListener('change', ()=>{ if(origImg){ prepareWorkCanvas(origCanvas.width, origCanvas.height); process(); } });

    stroke.addEventListener('input', ()=>{ strokeVal.textContent = stroke.value; });
    stroke.addEventListener('change', ()=>{ if(origImg){ prepareWorkCanvas(origCanvas.width, origCanvas.height); process(); } });

    color.addEventListener('change', renderPreview);

    scale.addEventListener('input', ()=>{ scaleVal.textContent = parseFloat(scale.value).toFixed(2)+'×'; });
  </script>
</body>
</html>