<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Signature Studio — Tách nền & chỉnh màu nét ký</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Canvas checkerboard background for transparency preview */
    .checker {
      background-image: linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                        linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                        linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
    input[type="range"] { accent-color: #111827; }
    .btn { @apply px-3 py-2 rounded-2xl shadow-sm border text-sm font-medium; }
    .btn-primary { @apply bg-black text-white hover:bg-gray-800; }
    .btn-ghost { @apply hover:bg-gray-100; }
    .label { @apply text-xs uppercase tracking-wider text-gray-500; }
  </style>
</head>
<body class="bg-white text-gray-900">
  <header class="max-w-6xl mx-auto px-4 py-6">
    <h1 class="text-2xl md:text-3xl font-bold">✍️ Signature Studio</h1>
    <p class="text-gray-600 mt-1">Tách nền chữ ký từ ảnh chụp, chỉnh nét, đổi màu, scale và xuất PNG nền trong — chạy 100% trên trình duyệt.</p>
  </header>

  <main class="max-w-6xl mx-auto px-4 pb-24">
    <!-- Upload & Actions -->
    <section class="grid lg:grid-cols-3 gap-6 items-start">
      <div class="lg:col-span-1 space-y-4">
        <div class="p-4 border rounded-2xl">
          <label class="label">1) Tải ảnh chữ ký</label>
          <input id="fileInput" type="file" accept="image/*" class="mt-2 w-full" />
          <p class="text-xs text-gray-500 mt-2">Tip: Chụp trên giấy trắng, ánh sáng đều, nét ký đậm.</p>
        </div>

        <div class="p-4 border rounded-2xl space-y-4">
          <div>
            <div class="flex items-center justify-between">
              <label class="label">Ngưỡng tách nền (Threshold)</label>
              <label class="inline-flex items-center gap-2 text-xs">
                <input id="autoOtsu" type="checkbox" class="mr-1" checked /> Auto (Otsu)
              </label>
            </div>
            <input id="thresh" type="range" min="0" max="255" value="128" class="w-full" />
            <div class="text-xs text-gray-500">Giá trị: <span id="threshVal">128</span></div>
          </div>

          <div>
            <label class="label">Độ dày nét</label>
            <input id="stroke" type="range" min="-5" max="5" value="0" class="w-full" />
            <div class="text-xs text-gray-500">Mỏng ⟵ <span id="strokeVal">0</span> ⟶ Đậm</div>
          </div>

          <div>
            <div class="flex items-center justify-between">
              <label class="label">Màu chữ ký</label>
              <input id="color" type="color" value="#111111" class="w-10 h-8 border rounded-md p-0" />
            </div>
          </div>

          <div>
            <label class="label">Scale (kích thước xuất)</label>
            <input id="scale" type="range" min="0.25" max="3" step="0.05" value="1" class="w-full" />
            <div class="text-xs text-gray-500"><span id="scaleVal">1.00×</span></div>
          </div>

          <div class="flex gap-2 pt-2">
            <button id="processBtn" class="btn btn-primary">Tách nền</button>
            <button id="resetBtn" class="btn btn-ghost">Reset</button>
          </div>
        </div>

        <div class="p-4 border rounded-2xl space-y-2">
          <button id="exportBtn" class="btn btn-primary w-full">⬇️ Xuất PNG nền trong</button>
          <p class="text-xs text-gray-500">PNG sẽ được crop sát nét ký, nền trong suốt, màu theo chọn.</p>
        </div>
      </div>

      <div class="lg:col-span-2 grid md:grid-cols-2 gap-6">
        <div class="border rounded-2xl overflow-hidden">
          <div class="p-3 border-b text-sm font-medium">Ảnh gốc</div>
          <div class="checker flex items-center justify-center min-h-[300px]">
            <canvas id="origCanvas" class="max-w-full"></canvas>
          </div>
        </div>
        <div class="border rounded-2xl overflow-hidden">
          <div class="p-3 border-b text-sm font-medium">Kết quả (preview)</div>
          <div class="checker flex items-center justify-center min-h-[300px]">
            <canvas id="outCanvas" class="max-w-full"></canvas>
          </div>
        </div>
      </div>
    </section>

    <section class="mt-8 text-xs text-gray-500 leading-relaxed">
      <details>
        <summary class="cursor-pointer select-none font-medium text-gray-700">Cách hoạt động (kỹ thuật)</summary>
        <div class="mt-2 space-y-2">
          <p>App chạy 100% client-side. Ảnh được chuyển sang grayscale, tìm ngưỡng tự động bằng Otsu (có thể chỉnh tay). Sau đó tạo mask nét ký, áp dụng co/giãn (erosion/dilation) để mỏng/đậm nét, đổi màu theo lựa chọn, scale lại và xuất PNG nền trong.</p>
          <p>Lưu ý: Ảnh chụp bóng/nhăn giấy có thể cần tăng/giảm threshold một chút để loại bỏ nhiễu.</p>
        </div>
      </details>
    </section>
  </main>

  <footer class="max-w-6xl mx-auto px-4 pb-8 text-xs text-gray-400">
    <p>© 2025 Signature Studio. Made for GitHub Pages.</p>
  </footer>

  <script>
    const fileInput = document.getElementById('fileInput');
    const origCanvas = document.getElementById('origCanvas');
    const outCanvas = document.getElementById('outCanvas');
    const processBtn = document.getElementById('processBtn');
    const exportBtn = document.getElementById('exportBtn');
    const resetBtn  = document.getElementById('resetBtn');

    const thresh = document.getElementById('thresh');
    const threshVal = document.getElementById('threshVal');
    const autoOtsu = document.getElementById('autoOtsu');
    const stroke = document.getElementById('stroke');
    const strokeVal = document.getElementById('strokeVal');
    const color = document.getElementById('color');
    const scale = document.getElementById('scale');
    const scaleVal = document.getElementById('scaleVal');

    let origImg = null; // Image object
    let mask = null;    // Uint8Array (0/1) for foreground
    let workW = 0, workH = 0;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function drawImageToCanvas(img, canvas, maxDim=1600){
      const ratio = Math.min(maxDim / img.width, maxDim / img.height, 1);
      const w = Math.round(img.width * ratio);
      const h = Math.round(img.height * ratio);
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,w,h);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, w, h);
      return {w, h};
    }

    function getImageData(canvas){
      const ctx = canvas.getContext('2d');
      return ctx.getImageData(0,0,canvas.width, canvas.height);
    }

    function putImageData(canvas, imgData){
      const ctx = canvas.getContext('2d');
      canvas.width = imgData.width; canvas.height = imgData.height;
      ctx.putImageData(imgData, 0, 0);
    }

    function toGray(data){
      const len = data.length/4;
      const gray = new Uint8ClampedArray(len);
      for(let i=0, j=0; i<data.length; i+=4, j++){
        const r=data[i], g=data[i+1], b=data[i+2];
        // Perceptual luma
        gray[j] = (0.2126*r + 0.7152*g + 0.0722*b) | 0;
      }
      return gray;
    }

    function otsuThreshold(gray){
      // histogram
      const hist = new Uint32Array(256);
      for(let i=0;i<gray.length;i++) hist[gray[i]]++;
      const total = gray.length;
      let sum = 0; for(let t=0;t<256;t++) sum += t * hist[t];
      let sumB=0, wB=0, wF=0, varMax=0, threshold=127;
      for(let t=0;t<256;t++){
        wB += hist[t]; if(wB===0) continue;
        wF = total - wB; if(wF===0) break;
        sumB += t * hist[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const varBetween = wB*wF*(mB - mF)*(mB - mF);
        if(varBetween > varMax){ varMax = varBetween; threshold = t; }
      }
      return threshold;
    }

    function makeMask(gray, threshold){
      const m = new Uint8Array(gray.length);
      for(let i=0;i<gray.length;i++){
        // Assume foreground is darker than paper
        m[i] = gray[i] < threshold ? 1 : 0;
      }
      return m;
    }

    function dilate(m, w, h, r){
      if(r<=0) return m;
      const out = new Uint8Array(m.length);
      const rr = r|0;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          let val = 0;
          for(let dy=-rr; dy<=rr && !val; dy++){
            const yy = y+dy; if(yy<0||yy>=h) continue;
            for(let dx=-rr; dx<=rr; dx++){
              const xx = x+dx; if(xx<0||xx>=w) continue;
              const idx = yy*w+xx;
              if(m[idx]){ val=1; break; }
            }
          }
          out[y*w+x] = val;
        }
      }
      return out;
    }

    function erode(m, w, h, r){
      if(r<=0) return m;
      const out = new Uint8Array(m.length);
      const rr = r|0;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          let val = 1;
          for(let dy=-rr; dy<=rr && val; dy++){
            const yy = y+dy; if(yy<0||yy>=h) { val=0; break; }
            for(let dx=-rr; dx<=rr; dx++){
              const xx = x+dx; if(xx<0||xx>=w){ val=0; break; }
              const idx = yy*w+xx;
              if(!m[idx]){ val=0; break; }
            }
          }
          out[y*w+x] = val;
        }
      }
      return out;
    }

    function applyStrokeAdjust(m, w, h, s){
      if(s===0) return m;
      if(s>0) return dilate(m, w, h, s);
      return erode(m, w, h, -s);
    }

    function maskToImageData(m, w, h, hexColor){
      const img = new ImageData(w, h);
      const {r,g,b} = hexToRgb(hexColor);
      for(let i=0, j=0; i<img.data.length; i+=4, j++){
        if(m[j]){
          img.data[i] = r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255; // opaque stroke
        } else {
          img.data[i] = 0; img.data[i+1]=0; img.data[i+2]=0; img.data[i+3]=0;   // transparent
        }
      }
      return img;
    }

    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : {r:17,g:17,b:17};
    }

    function findBoundingBox(m, w, h){
      let minX=w, minY=h, maxX=-1, maxY=-1;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          if(m[y*w+x]){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
        }
      }
      if(maxX<minX || maxY<minY) return {x:0,y:0,w:0,h:0};
      return {x:minX, y:minY, w:maxX-minX+1, h:maxY-minY+1};
    }

    function renderPreview(){
      if(!origImg || !mask) return;
      const {r,g,b} = hexToRgb(color.value);
      const w = workW, h = workH;
      const img = new ImageData(w, h);
      for(let i=0, j=0; i<img.data.length; i+=4, j++){
        if(mask[j]){ img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255; }
        else { img.data[i]=0; img.data[i+1]=0; img.data[i+2]=0; img.data[i+3]=0; }
      }
      putImageData(outCanvas, img);
    }

    function process(){
      if(!origImg){ alert('Hãy tải ảnh chữ ký trước đã nhé!'); return; }
      const ctx = origCanvas.getContext('2d');
      const imgData = ctx.getImageData(0,0,origCanvas.width, origCanvas.height);
      const gray = toGray(imgData.data);
      let t = autoOtsu.checked ? otsuThreshold(gray) : parseInt(thresh.value);
      if(!autoOtsu.checked) t = clamp(parseInt(thresh.value), 0, 255);
      thresh.value = t; threshVal.textContent = String(t);
      let m = makeMask(gray, t);
      const s = parseInt(stroke.value);
      m = applyStrokeAdjust(m, origCanvas.width, origCanvas.height, s);
      mask = m; workW = origCanvas.width; workH = origCanvas.height;
      renderPreview();
    }

    function exportPng(){
      if(!mask){ alert('Chưa có kết quả để xuất. Nhấn "Tách nền" trước nhé!'); return; }
      const w = workW, h = workH;
      const bbox = findBoundingBox(mask, w, h);
      if(bbox.w===0 || bbox.h===0){ alert('Không phát hiện được nét ký. Hãy giảm threshold hoặc tăng độ dày nét.'); return; }

      const scaleFactor = parseFloat(scale.value);
      const tmp = document.createElement('canvas');
      tmp.width = Math.max(1, Math.round(bbox.w * scaleFactor));
      tmp.height = Math.max(1, Math.round(bbox.h * scaleFactor));
      const tctx = tmp.getContext('2d');
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = 'high';

      // Create colored ImageData cropped to bbox
      const cropped = new ImageData(bbox.w, bbox.h);
      const {r,g,b} = hexToRgb(color.value);
      for(let y=0; y<bbox.h; y++){
        for(let x=0; x<bbox.w; x++){
          const srcIdx = (bbox.y + y) * w + (bbox.x + x);
          const dstIdx = (y * bbox.w + x) * 4;
          if(mask[srcIdx]){
            cropped.data[dstIdx] = r;
            cropped.data[dstIdx+1] = g;
            cropped.data[dstIdx+2] = b;
            cropped.data[dstIdx+3] = 255;
          } else {
            cropped.data[dstIdx] = 0;
            cropped.data[dstIdx+1] = 0;
            cropped.data[dstIdx+2] = 0;
            cropped.data[dstIdx+3] = 0;
          }
        }
      }

      // Draw cropped then scale
      const stage = document.createElement('canvas');
      stage.width = bbox.w; stage.height = bbox.h;
      stage.getContext('2d').putImageData(cropped, 0, 0);
      tctx.drawImage(stage, 0, 0, tmp.width, tmp.height);

      const url = tmp.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'signature.png';
      a.click();
    }

    function resetUI(){
      thresh.value = 128; threshVal.textContent = '128'; autoOtsu.checked = true;
      stroke.value = 0; strokeVal.textContent = '0';
      color.value = '#111111';
      scale.value = 1; scaleVal.textContent = '1.00×';
      const ctxO = origCanvas.getContext('2d');
      ctxO.clearRect(0,0,origCanvas.width, origCanvas.height);
      const ctxOut = outCanvas.getContext('2d');
      ctxOut.clearRect(0,0,outCanvas.width, outCanvas.height);
      origImg = null; mask = null; workW = 0; workH = 0;
    }

    // Events
    fileInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      const img = new Image();
      img.onload = ()=>{
        drawImageToCanvas(img, origCanvas);
        origImg = img; mask = null; workW = origCanvas.width; workH = origCanvas.height;
        // Auto process on load for quick preview
        process();
      };
      img.onerror = ()=> alert('Không mở được ảnh. Hãy thử lại với file .jpg/.png/.webp');
      const reader = new FileReader();
      reader.onload = (ev)=>{ img.src = ev.target.result; };
      reader.readAsDataURL(file);
    });

    processBtn.addEventListener('click', process);
    exportBtn.addEventListener('click', exportPng);
    resetBtn.addEventListener('click', resetUI);

    autoOtsu.addEventListener('change', ()=>{ thresh.disabled = autoOtsu.checked; process(); });
    thresh.addEventListener('input', ()=>{ threshVal.textContent = thresh.value; });
    thresh.addEventListener('change', process);

    stroke.addEventListener('input', ()=>{ strokeVal.textContent = stroke.value; });
    stroke.addEventListener('change', process);

    color.addEventListener('change', renderPreview);

    scale.addEventListener('input', ()=>{ scaleVal.textContent = parseFloat(scale.value).toFixed(2)+'×'; });
  </script>
</body>
</html>
